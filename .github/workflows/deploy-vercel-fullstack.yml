name: Deploy Full-Stack Branch to Vercel (Backend First, Then Frontend)

on:
  pull_request:
    types: [opened, synchronize, reopened]

jobs:
  deploy-backend:
    runs-on: ubuntu-latest
    outputs:
      backend-url: ${{ steps.deploy-backend.outputs.url }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'
          cache-dependency-path: backend/package-lock.json

      - name: Install dependencies
        run: |
          cd backend
          npm ci

      - name: Install Vercel CLI
        run: npm install --global vercel@latest

      - name: Deploy Backend Branch to Vercel (Preview)
        id: deploy-backend
        run: |
          cd backend
          echo "Deploying backend to Vercel..."
          echo "Setting up Vercel project linking..."
          # Ensure .vercel directory exists and create project.json
          mkdir -p .vercel
          echo "{\"orgId\":\"$VERCEL_ORG_ID\",\"projectId\":\"$VERCEL_PROJECT_ID\"}" > .vercel/project.json
          
          # Try vercel pull first, if it fails, proceed with direct deployment
          if vercel pull --yes --environment=preview --token=${{ secrets.VERCEL_TOKEN }}; then
            echo "âœ… Successfully pulled Vercel configuration"
            vercel build --token=${{ secrets.VERCEL_TOKEN }}
            DEPLOYMENT_URL=$(vercel deploy --prebuilt --token=${{ secrets.VERCEL_TOKEN }})
          else
            echo "âš ï¸ Vercel pull failed, proceeding with direct deployment"
            DEPLOYMENT_URL=$(vercel deploy --token=${{ secrets.VERCEL_TOKEN }})
          fi
          
          echo "url=$DEPLOYMENT_URL" >> $GITHUB_OUTPUT
          echo ""
          echo "ðŸŽ¯ BACKEND DEPLOYED SUCCESSFULLY!"
          echo "ðŸ“ Backend URL: $DEPLOYMENT_URL"
          echo ""
        env:
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_BACKEND_PROJECT_ID }}

      - name: Debug backend deployment outputs
        run: |
          echo "Backend deployment outputs:"
          echo "preview-url: ${{ steps.deploy-backend.outputs.url }}"

      - name: Test backend deployment
        run: |
          BACKEND_URL="${{ steps.deploy-backend.outputs.url }}"
          echo "Testing backend at: $BACKEND_URL"
          
          # Test if backend URL contains "backend"
          if [[ "$BACKEND_URL" != *"backend"* ]]; then
            echo "âŒ ERROR: Backend URL doesn't contain 'backend': $BACKEND_URL"
            echo "This looks like a frontend URL, not a backend URL!"
            exit 1
          fi
          
          # Test if backend is accessible
          echo "Testing backend health endpoint..."
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$BACKEND_URL/api/health" || echo "FAILED")
          
          if [ "$HTTP_STATUS" = "200" ]; then
            echo "âœ… Backend is responding correctly at: $BACKEND_URL"
          else
            echo "âŒ Backend health check failed. Status: $HTTP_STATUS"
            echo "Trying to get more info..."
            curl -v "$BACKEND_URL/api/health" || true
            exit 1
          fi
          
          echo "Backend URL verified: $BACKEND_URL"

  deploy-frontend:
    runs-on: ubuntu-latest
    needs: deploy-backend
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Install dependencies
        run: |
          cd frontend
          npm ci

      - name: Install Vercel CLI
        run: npm install --global vercel@latest

      - name: Debug environment variables
        run: |
          echo "Environment variables for frontend build:"
          echo "VITE_API_BASE_URL: ${{ needs.deploy-backend.outputs.backend-url }}"
          echo "Backend URL from previous job: ${{ needs.deploy-backend.outputs.backend-url }}"

      - name: Build frontend locally
        run: |
          cd frontend
          echo "Building frontend locally with backend URL..."
          npm run build
        env:
          VITE_API_BASE_URL: ${{ needs.deploy-backend.outputs.backend-url }}

      - name: Deploy Frontend Branch to Vercel (Preview)
        id: deploy-frontend
        run: |
          cd frontend
          echo "Setting up Vercel configuration..."
          # Ensure .vercel directory exists and create project.json
          mkdir -p .vercel
          echo "{\"orgId\":\"$VERCEL_ORG_ID\",\"projectId\":\"$VERCEL_PROJECT_ID\"}" > .vercel/project.json
          
          echo "Current directory: $(pwd)"
          echo "Dist folder contents:"
          ls -la dist/
          
          # Deploy from current directory with backend URL as environment variable
          echo "Deploying frontend to Vercel..."
          echo "Setting VITE_API_BASE_URL to: ${{ needs.deploy-backend.outputs.backend-url }}"
          DEPLOYMENT_URL=$(vercel deploy --token=${{ secrets.VERCEL_TOKEN }} --build-env VITE_API_BASE_URL=${{ needs.deploy-backend.outputs.backend-url }})
          echo "url=$DEPLOYMENT_URL" >> $GITHUB_OUTPUT
          echo ""
          echo "ðŸŒŸ FRONTEND DEPLOYED SUCCESSFULLY!"
          echo "ðŸ”— Frontend URL: $DEPLOYMENT_URL"
          echo "ðŸ”Œ Connected to Backend: ${{ needs.deploy-backend.outputs.backend-url }}"
          echo ""
        env:
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_FRONTEND_PROJECT_ID }}

      - name: Test integration
        run: |
          FRONTEND_URL="${{ steps.deploy-frontend.outputs.url }}"
          BACKEND_URL="${{ needs.deploy-backend.outputs.backend-url }}"
          
          echo "ðŸ§ª Integration Test Results:"
          echo "Frontend: $FRONTEND_URL"
          echo "Backend: $BACKEND_URL"
          
          # Test if frontend can reach backend
          echo "Testing if frontend can reach backend..."
          
          # Use a simple curl to test CORS and connectivity
          curl -H "Origin: $FRONTEND_URL" \
               -H "Access-Control-Request-Method: GET" \
               -H "Access-Control-Request-Headers: Content-Type" \
               -X OPTIONS \
               "$BACKEND_URL/api/setup/health/hello" -v || echo "CORS preflight failed"
          
          echo "âœ… Integration test completed. Check browser console for frontend logs."

      - name: ðŸš€ Deployment Summary
        run: |
          FRONTEND_URL="${{ steps.deploy-frontend.outputs.url }}"
          BACKEND_URL="${{ needs.deploy-backend.outputs.backend-url }}"
          
          echo ""
          echo "======================================================"
          echo "ðŸŽ‰ DEPLOYMENT SUCCESSFUL! ðŸŽ‰"
          echo "======================================================"
          echo ""
          echo "ðŸŒ FRONTEND: $FRONTEND_URL"
          echo "âš¡ BACKEND:  $BACKEND_URL"
          echo ""
          echo "ðŸ“ Quick Test Links:"
          echo "   â€¢ Frontend App: $FRONTEND_URL"
          echo "   â€¢ Backend Health: $BACKEND_URL/api/health"
          echo "   â€¢ Backend API: $BACKEND_URL/api"
          echo ""
          echo "âœ… Both services are deployed and integrated!"
          echo "======================================================"
          
          # Create GitHub Actions Summary
          cat >> $GITHUB_STEP_SUMMARY << EOF
          ## ðŸš€ Deployment Successful!
          
          Your branch has been successfully deployed to Vercel preview environments:
          
          ### ðŸŒ Frontend Application
          **URL:** [$FRONTEND_URL]($FRONTEND_URL)
          
          ### âš¡ Backend API  
          **URL:** [$BACKEND_URL]($BACKEND_URL)
          
          ### ðŸ§ª Quick Test Links
          - [Frontend App]($FRONTEND_URL) - Main application interface
          - [Backend Health Check]($BACKEND_URL/api/health) - API health status
          - [Backend API Base]($BACKEND_URL/api) - API documentation
          
          ### âœ… Integration Status
          Both frontend and backend are deployed and properly connected!
          
          ---
          *This deployment will be available until the PR is closed or merged.*
          EOF

      - name: ðŸ’¬ Update PR with deployment URLs
        uses: actions/github-script@v7
        with:
          script: |
            const frontendUrl = '${{ steps.deploy-frontend.outputs.url }}';
            const backendUrl = '${{ needs.deploy-backend.outputs.backend-url }}';
            
            const commentBody = `## ðŸš€ Preview Deployment Ready!

            Your changes have been deployed and are ready for testing:

            ### ðŸŒ Frontend Application
            **Live Preview:** [${frontendUrl}](${frontendUrl})

            ### âš¡ Backend API
            **API Endpoint:** [${backendUrl}](${backendUrl})

            ### ðŸ§ª Quick Test Links
            - [ðŸ“± Frontend App](${frontendUrl}) - Test the user interface
            - [â¤ï¸ Backend Health](${backendUrl}/api/health) - Verify API status  
            - [ðŸ“š API Documentation](${backendUrl}/api) - Explore endpoints

            ---
            âœ… **Integration Status:** Frontend and backend are connected and ready for testing!

            *ðŸ”„ Last updated: ${new Date().toLocaleString()} UTC*
            
            <!-- DEPLOYMENT_COMMENT_MARKER -->`;

            // Find existing deployment comment
            const comments = await github.rest.issues.listComments({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
            });

            const existingComment = comments.data.find(comment => 
              comment.body.includes('<!-- DEPLOYMENT_COMMENT_MARKER -->')
            );

            if (existingComment) {
              // Update existing comment
              await github.rest.issues.updateComment({
                comment_id: existingComment.id,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: commentBody
              });
              console.log('âœ… Updated existing deployment comment');
            } else {
              // Create new comment if none exists
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: commentBody
              });
              console.log('âœ… Created new deployment comment');
            } 